namespace Proxy
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("代理模式!");
            //代理模式（Proxy Pattern）是一种结构型设计模式，它通过创建一个代理对象来控制对另一个对象的访问。代理对象可以充当原始对象的替代品，对其进行一些额外的操作或控制访问权限。
            //代理模式的核心思想是在客户端和目标对象之间引入一个代理对象，客户端通过代理对象来访问目标对象，从而实现对目标对象的间接访问。代理对象可以拦截客户端的请求，并在必要时调用目标对象的方法，还可以在目标对象的方法执行前后进行一些额外的操作。
            //代理模式常见的应用场景包括：
            //1.远程代理：当目标对象存在于远程服务器上，客户端无法直接访问时，可以使用代理模式来通过网络通信来访问远程对象。
            //2.虚拟代理：当创建和加载一个对象需要很大开销时，可以使用代理模式延迟对象的实例化或加载，只在真正需要时才创建或加载对象。
            //3.安全代理：在访问目标对象前，代理对象可以进行安全验证，验证客户端是否有权限访问目标对象。

            //代理模式适用于以下情况：
            //1.远程访问：当目标对象位于远程服务器上，需要通过网络进行访问时，可以使用代理模式来隐藏底层的网络通信细节，提供一个本地代理对象来代替远程对象的访问。
            //2.延迟加载：当创建或加载一个对象需要较大的开销时，可以使用代理模式延迟对象的实例化或加载，只有在需要时才创建或加载对象，从而提高系统的性能和响应速度。
            //3.安全控制：当需要对目标对象的访问进行控制和限制时，可以使用代理模式来进行安全验证、权限检查等，确保只有符合条件的客户端可以访问目标对象。
            //4.缓存代理：当需要缓存目标对象的结果或方法调用时，可以使用代理模式来提供一个代理对象，负责缓存和管理目标对象的结果，避免重复计算或访问。

            //下面是一个简单的示例，演示如何使用缓存代理来实现一个简单的计算结果缓存
            ICalculator calculator = new CalculatorProxy();
            // 第一次计算，结果被缓存
            int result1 = calculator.Calculate(5);
            Console.WriteLine($"Result 1: {result1}");
            // 第二次计算，结果从缓存中获取
            int result2 = calculator.Calculate(5);
            Console.WriteLine($"Result 2: {result2}");
            // 第三次计算，结果被缓存
            int result3 = calculator.Calculate(10);
            Console.WriteLine($"Result 3: {result3}");
            // 在上述示例中，我们定义了一个计算器接口 ICalculator，其中包含一个 Calculate 方法用于计算结果。具体的计算器对象 Calculator 实现了该接口，用于执行实际的计算操作。代理对象 CalculatorProxy 实现了计算器接口，它包含了对实际计算器对象的引用，并维护了一个缓存字典用于存储计算结果。
            //在客户端代码中，我们通过代理对象来执行计算操作。代理对象首先检查缓存中是否已经存在计算结果，如果存在，则直接返回缓存中的结果；如果不存在，则调用实际计算器对象的方法进行计算，并将结果存入缓存中。通过这种方式，可以避免重复计算相同的数字，提高计算的效率。
            Console.ReadLine();
        }
    }
}