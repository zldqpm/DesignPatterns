namespace State
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("状态模式!");
            //状态模式是一种行为设计模式，它允许对象在内部状态改变时改变其行为。它将对象的行为封装在不同的状态对象中，并通过状态对象之间的切换来改变对象的行为。

            //使用状态模式的主要场景包括：
            //1.当对象的行为随着内部状态的改变而改变时，可以使用状态模式。状态模式将不同的行为封装在不同的状态类中，通过状态对象的切换来改变对象的行为。
            //2.当有复杂的条件语句用于控制对象的行为时，可以考虑使用状态模式。状态模式可以将这些条件语句封装在状态类中，使得代码更加清晰、可维护。
            //3.当对象需要根据不同的状态执行不同的操作时，可以使用状态模式。状态模式可以将每个状态的操作封装在状态类中，使得对象的操作与状态解耦，更加灵活。

            //状态模式适用于以下场景：
            //1.对象的行为取决于其内部状态，并且需要在运行时根据状态改变行为。
            //2.对象的行为包含大量的条件语句，这些条件语句依赖于对象的状态。
            //3.对象的状态可以被多个对象共享，并且这些对象需要根据状态变化而采取不同的行动。

            //举例应用场景可以是一个电梯控制系统。电梯可以处于不同的状态，如停止、运行、故障等。根据电梯的状态，电梯控制系统需要执行不同的操作，如开门、关门、上行、下行等。
            Elevator elevator = new Elevator();

            // 电梯初始状态为停止状态
            elevator.OpenDoor();  // 输出：打开电梯门
            elevator.CloseDoor(); // 输出：关闭电梯门
            elevator.GoUp();      // 输出：电梯运行中，无法上行
            // 切换到运行状态
            elevator.SetState(new RunState());
            elevator.OpenDoor();  // 输出：电梯运行中，无法打开门
            elevator.CloseDoor(); // 输出：电梯运行中，无法关闭门
            elevator.GoUp();      // 输出：电梯运行中，无法上行
            elevator.GoDown();    // 输出：电梯运行中，无法下行
            Console.ReadLine();
            //在上述示例中，Elevator 类代表电梯，其内部状态通过 ElevatorState 类的具体子类来表示。根据电梯的状态，调用相应的操作方法，具体的实现由状态类来完成。通过使用状态模式，可以使得电梯控制系统的代码更加清晰、可扩展，并且能够方便地根据电梯的状态执行不同的操作。
        }
    }
}