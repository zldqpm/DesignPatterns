namespace Iterator
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("迭代器模式!");
            //迭代器模式是一种行为设计模式，它提供一种顺序访问聚合对象中各个元素的方法，而不需要暴露该对象的内部表示。通过使用迭代器模式，可以在不暴露聚合对象的内部结构的情况下，遍历聚合对象中的元素。
            //迭代器模式的主要参与者包括以下几个角色：
            //1.抽象迭代器（Iterator）：定义了访问和遍历聚合对象元素的接口。
            //2.具体迭代器（ConcreteIterator）：实现抽象迭代器接口，负责具体的遍历逻辑。
            //3.抽象聚合对象（Aggregate）：定义了创建迭代器对象的接口。
            //4.具体聚合对象（ConcreteAggregate）：实现抽象聚合对象接口，负责创建具体迭代器对象。

            //迭代器模式在以下场景中非常有用：
            //1.需要遍历聚合对象的元素，但不希望暴露聚合对象的内部结构。
            //2.需要提供多种遍历方式，而不影响聚合对象的实现。
            //3.需要逐步访问聚合对象的元素，而不是一次性获取所有元素。
            //下面是几个迭代器模式的应用场景举例：
            //1.遍历集合：迭代器模式常用于遍历各种集合类型，如数组、链表、树等。通过使用迭代器，可以在不暴露集合内部结构的情况下，按照特定的顺序访问集合中的元素。
            //2.文件系统遍历：在处理文件系统中的目录和文件时，可以使用迭代器模式。迭代器模式使得我们可以递归地遍历文件夹和文件，并进行特定操作，而不需要暴露文件系统的内部实现细节。
            //3.数据库结果集处理：在处理数据库查询结果时，可以使用迭代器模式来逐行遍历结果集并进行相应的操作。这样可以将数据访问层和业务逻辑层解耦，提供更灵活和可扩展的处理方式。
            //4.游戏开发中的场景管理：在游戏开发中，经常需要处理各种场景的切换和管理。迭代器模式可以用于实现场景管理器，通过迭代器来遍历和切换不同的游戏场景。
            //总之，迭代器模式适用于需要遍历和访问聚合对象的场景，同时希望保持聚合对象的内部结构私有化。它提供了一种分离遍历算法和聚合对象的方式，使得遍历操作更加灵活和可扩展。

            //以下是一个使用迭代器模式的简单示例，展示如何遍历一个集合对象：
            // 创建具体聚合对象
            ConcreteAggregate aggregate = new ConcreteAggregate();

            // 添加元素到聚合对象
            aggregate.AddItem("Item 1");
            aggregate.AddItem("Item 2");
            aggregate.AddItem("Item 3");
            aggregate.AddItem("Item 4");

            // 创建迭代器并遍历元素
            IIterator iterator = aggregate.CreateIterator();
            while (iterator.HasNext())
            {
                object item = iterator.Next();
                Console.WriteLine(item);
            }
            //在上述示例中，我们首先定义了抽象迭代器接口 IIterator，并实现了具体迭代器类 ConcreteIterator。然后，我们定义了抽象聚合对象接口 IAggregate，并实现了具体聚合对象类 ConcreteAggregate。最后，在主程序中，我们创建具体聚合对象并添加元素，然后通过创建迭代器对象并使用它来遍历聚合对象中
            Console.ReadLine();
        }
    }
}